model Divertimento

class Parque
end

class Empresa
end

class Noria < Atraccion
end

class MRusa < Atraccion
end

abstract class Atraccion
        attributes
                calle : String
                averia : Boolean init: false
                enFuncionamiento : Boolean init: false
        operations

            arreglado() begin
                self.averia := false;
            end
            pre averiado: self.averia
            post arreglado: not self.averia

            averiado() begin
                self.averia := true;
            end
            post averiado: self.averia

            funcionamiento() begin
                self.enFuncionamiento := true;
            end
            pre noAveriado: not self.averia
            post enFuncionamient: self.enFuncionamiento

            mantenimiento() begin
                if self.oclIsTypeOf(Noria) then
                    for ve in self.oclAsType(Noria).vehiculo
                        do ve.comprobarAveria(self, self.parque.cra);
                    end;
                end;

                if self.oclIsTypeOf(MRusa) then
                    for va in self.oclAsType(MRusa).vagon
                        do va.comprobarAveria(self, self.parque.cra);
                    end;
                end;
            end

            parada() begin
                self.enFuncionamiento := false;
                self.mantenimiento()
            end
            pre enFuncionamiento: self.enFuncionamiento
            post parado: not self.enFuncionamiento

        statemachines
            
            psm FuncionamientoAtraccion
                states
                    inicio:initial
                    parada[not enFuncionamiento]
                    enFuncionamiento[enFuncionamiento]
                    averiado[averia]
                transitions
                    inicio -> parada { create }

                    parada -> enFuncionamiento { funcionamiento() }

                    enFuncionamiento -> parada { parada() }

                    enFuncionamiento -> averiado { averiado() }

                    parada -> averiado { averiado() }

                    averiado -> averiado { averiado() }

                    averiado -> parada { arreglado() }
            end
end

abstract class ComponenteAtraccion
        attributes
                numero : Integer
                estaAveriado : Boolean init: false
                estaInformado : Boolean init: false
        operations
            comprobarAveria(a:Atraccion, cra:CRA) begin
                if self.estaAveriado then
                    self.informarAveria(a, cra);
                end;
            end



            informarAveria(a:Atraccion, cra:CRA) begin
                insert(cra,self) into CRAComponente;
                a.averiado();
            end
            pre noInformadoAnteriormente: self.cra->size() = 0
            pre estaAveriado: self.estaAveriado
            post craInformada: self.cra->size() = self.cra@pre->size() + 1
            post atraccionInformada: a.averia

            averiar() begin
                self.estaAveriado := true;
                if self.oclIsTypeOf(Vehiculo) then self.oclAsType(Vehiculo).informarAveria(self.oclAsType(Vehiculo).noria, self.oclAsType(Vehiculo).noria.parque.cra -> asOrderedSet() -> first()) end;
                if self.oclIsTypeOf(Vagon) then self.oclAsType(Vagon).informarAveria(self.oclAsType(Vagon).mrusa, self.oclAsType(Vagon).mrusa.parque.cra -> asOrderedSet() -> first()) end;
            end
            pre noAveriadoAntes: not self.estaAveriado
            post averiadoDespues: self.estaAveriado

            reparado() begin
                self.estaAveriado := false;
                self.estaInformado := false;
            end
            pre averiadoAntes: self.estaAveriado
            post noAveriadoDespues: not self.estaAveriado
            post noInformadoDespues: not self.estaInformado

            esInformado() begin
                self.estaInformado := true;
            end
            pre noInformadoAntes: not self.estaInformado
            post informadoDespues: self.estaInformado
end

class Vehiculo < ComponenteAtraccion
end

class Vagon < ComponenteAtraccion
end

class Dispositivo
        attributes
                averiasResueltas : Integer
                init : 0
end

class CRA
    operations
        buscarOperario(c : ComponenteAtraccion) begin
            declare o : Operario;
            o := self.dispositivo.operario -> select(o : Operario | o.estaLibre) -> asOrderedSet() -> first();
            if(o <> Undefined) then
                insert(c, o.dispositivo) into AveriaDispositivo;
                o.ocupado();
                --o.repararAveria(c);
            else
                self.informar(c);
            end
        end
            pre componenteAveriado: c.estaAveriado
            pre craInformada: c.cra <> Undefined

        informar(c : ComponenteAtraccion) begin
            c.esInformado();
        end
end

class Operario
        attributes
            estaLibre : Boolean init: true
        operations
            repararAveria(c: ComponenteAtraccion)
            begin
                delete (c, self.dispositivo) from AveriaDispositivo;
                delete (c.cra, c) from CRAComponente;
                self.libre();
                self.dispositivo.averiasResueltas := self.dispositivo.averiasResueltas+1;
                c.reparado();
                if c.oclIsTypeOf(Vehiculo) then c.oclAsType(Vehiculo).noria.mantenimiento() end;
                if c.oclIsTypeOf(Vagon) then c.oclAsType(Vagon).mrusa.mantenimiento() end;
            end
            pre asignado: not estaLibre
            pre averiado: c.estaAveriado
            pre componenteAsociado: self.dispositivo.averiado = c
            post libre: estaLibre
            post arreglado: not c.estaAveriado
            post masResueltos: dispositivo.averiasResueltas = dispositivo.averiasResueltas@pre + 1
        
            libre() begin
                self.estaLibre := true;
            end
            pre ocupadoAntes: not estaLibre
            post libreDespues: estaLibre

            ocupado() begin
                self.estaLibre := false;
            end
            pre libreAntes: estaLibre
            post ocupadoDespues: not estaLibre

        statemachines
            psm EstadoOperario
                states
                    inicio:initial
                    libre [estaLibre]
                    ocupado [not estaLibre]
                transitions
                    inicio -> libre { create }

                    libre -> ocupado { ocupado() }

                    ocupado -> libre { libre() }
            end
end

association Vagones between
    MRusa [1] role mrusa
    Vagon [*] role vagon
end

association Enganche between
    Noria [1] role noria
    Vehiculo [*] role vehiculo
end

association Parques between
    Empresa [1] role propietaria
    Parque [*] role parque
end

association Atracciones between
    Atraccion [*] role atraccion
    Parque [1] role parque
end

association DispositivoOperario between
    Dispositivo [1] role dispositivo
    Operario [0..1] role operario
end

association EnganchePosterior between
    Vagon [0..1] role enganchep
    Vagon [0..1] role enganchea
end

association CRAComponente between
    CRA [0..1] role cra
    ComponenteAtraccion [*] role componente
end

association CRADispositivo between
    CRA [1] role cra
    Dispositivo [*] role dispositivo
end

association CRAParque between
    CRA [1] role cra
    Parque [1] role parque
end

association AveriaDispositivo between
    ComponenteAtraccion [0..1] role averiado
    Dispositivo [0..1] role dispositivo
end

constraints
    context Dispositivo
        inv averiasResueltasMayorIgualZero: self.averiasResueltas >= 0
        inv averiasResueltasDistintoDeNull: self.averiasResueltas <> Undefined
    
    context ComponenteAtraccion
        inv numeroMayorZero: self.numero > 0

    context Vagon
        inv numeroVagonDistinto: Vagon.allInstances() -> isUnique(numero)

    context Vehiculo
        inv numeroVehiculoDistinto: Vehiculo.allInstances() -> isUnique(numero)